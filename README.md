# feature

**Planning**
  The history behind the idea:
    The project brief invites us to create something that we enjoy personally, so I tried to pull from personal stories for inspiration. As a kid, I often witnessed my mother holding tarot reading sessions for friends and family members. I was never a believer, but for a lot of relatives the mysticism behind Tarot was a kind of connection to a part of the family history that they'd lost touch with - my grandfather was from a large gypsy family, but my grandmother was not, so after they both died their children were not accepted by the rest of the family, which led to my mother and her siblings feeling like a portion of their ethnical heritage was lost. What little they did learn about their father's heritage was shrouded in mystery and magic.
    
 With this concept in mind, I decided to create a feature that can perform a simple tarot reading for the user. I want to recreate the experience as closely as possible, so I have planned the building of the feature based on the different steps of a reading:
 
  - Users need to set the intention for the reading by asking the cards to answer a specific question. For simplicity, this will be represented by a multiple-option menu where users can select one of the three most common questions: Love, Money & Health
  - User must break the deck of cards with their own hand to allow the cards to receive their energy. This obviously cannot be achieved exactly, but in order to approximate this experience the feature will ask users to shuffle the cards by pressing a button. This will actually shuffle the different card objects and assign them randomly across the deck in order to set up the next stage
  - Users must pick out a card from the deck, which will then be interpreted according to the question asked. Here, the feature will recall the original question posed and collect from the card selected the appropriate answer, which has been stored as a key in the object.

**Building**
  I've broken up the feature into blocks that I can iterate through and rather than try to work through the order of all steps of the feature in use (which would be, asking the question, then shuffling, then picking a card and finally reading it) I have laid out my work based on the perceived complexity of each task. Here I say 'perceived' because the first function created won't necessarily be the simplest, but it will be the one I can most easily create an MVP for, which allows me to increase the functions complexity over time as the rest of the feature takes shape.
  
  1. I started by laying out the basing HTML and styling it, of course. At this point the page simply shows 8 cards that are facing down. The cards are all stacked at the center of the page and there is one single button that will 'shuffle' the cards when pressed. Once this simple layout was achieved, I started working on my shuffle() function. Once the feature is complete this function will look much more complex, but for now it does the following:
    a) The array 'cards', which contains 8 objects representing each possible Tarot card, is shuffled with the sort() method
    b) The function iterates through an array of all html cards and assigns the name of each object in the cards array to the different htmml elements, storing it in their 'name' attribute.
    
    **debugging**
     One simple issue I noticed at this point came from the naming of arrays. When I created the array of objects that stores the different Tarot cards I named it 'cards', but the different HTML elements representing the physical cards have a class of cards and the array that identifies these in javascript is called 'deck'. All these names made perfect sense to me but once I started working with functions it was easy to get confused about whether I should iterate through 'cards' or 'deck', so I changed the name of the array of objects from 'cards' to 'tarot'. This is a name that should still be understandable for anyone else reading the code, but makes it much easier for me to remember which array I need to work with at any point.
     
     The second issue to correct came when adjusting the layout of the deck accross the page. In order to do this I crated a variable that stores all elements with the class of .card and called it 'deck', then I set the function shuffle() to swap the class .stacked for the class .lined on all the elements stored. The former class is set to display the elements at the center of the page, while the former lays them out across it's width. However, what I didn't realise at the time was that document.getElementsByClassName() creates an array.
     When the function did not work I attempted to debugg by commanding a console.log('deck'), since I understood the error was occurring whenever I tried to manipulate the elements in this varible. By seeing them laid out on the console as an array, I understood I needed to iterate through 'decks' and action each element stored there.
     
  2. The next step was to allow the user to see the card they had selected. I had been verifying the distribution of the different tarot objects by console logging different card elements, but in order to recreate the experience of picking a card, I needed to display it's face. For this I started working on the second function, read().
  Read() is called when any of the cards in 'deck' is clicked on and needs to identify the correct object within the array 'tarot' and recall it's keys. So it starts off by collecting the attribute 'name' from the element selected and comparing it to the 'name' key in each object of 'tarot'. From there, the function simply sets the innerHTML of the element selected to contain the and <img> element with the src attribute set to the value of the key 'image' inside the corresponding 'tarot' object. Once I could achieve this, I knew that displaying the rest of the information associated with that card would be a simple case of reproducing the same logic.
  
  **debugging**
  At this point the function was very simple and didn't require corrections, but once I started working on the next steps I realised that there was a necessary step I had neglected. In this basic iteration, read() was identifying the correct object within 'tarot' to work with by comparing it's name to the name attribute of the html element selected. This worked without issue but was not a realistic approach when I thought about collecting all the information that would be associated with each element. So I added one more step.
  The first step in the function is to declare a variable called 'selected'. Once the function identifies the correct object in 'tarot' to work with, it copies that object into 'selected'. This way, I can then call 'selected' in the following stages of the function and access the information needed with minimal effort.
